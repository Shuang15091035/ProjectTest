2016.10.7
移动构造函数：IntNum(IntNum &&n):ptx(n.ptx){//移动构造函数 &&是右值引用，函数返回的临时变量是右值
		n.ptx = nullptr;//原指针为空，指针转移
		cout << "Calling move constructor ..." << endl;
	}
string类：
s+t:将串s和t连接成一个新串。
s=t：用t更新s
s==t:判断相等。！=，<, <=,>,>=,按字典顺序比较s[i]访问下标。
string s1 = "abc",s2 = "def";
string s3 = s1 + s2; //s3 = "abcdef";
getline:可以输入整行字符串（要包含string）
getline(cin,s2);
输入字符串时可以使用其他字符作为字符串结束的标志（逗号，分号）,将分隔符号作为getline的第三个参数即可。例如：getline(cin,s2,‘；’)；

2016.10.6
静态数据成员：属于类不属于对象，使用静态数据成员
int Point::count = 0;//静态数据成员定义和初始化，使用类名限制；
class Point{
public:
	Point(int i = 0, int j = 0):x(i),y(i){}
	Point(Point &p){ x = p.x; y = p.y;count++;}
	~Point(){count--;}
	int getX(){return x;}
	int getY(){return y;}
	void showCount(){
		cout << "object coutn" << count <<endl;
	}
private:
	int x;
	int y;
	static int count;
};
int Point::count = 0;//静态数据成员定义和初始化，使用类名限制

int main(){
	Point p(1,2);
	p.showCount();
	Point b(p);
	b.showCount();
	return 0;
}
静态函数：处理静态数据
static void showCount(){//静态方法，访问静态成员变量，
		cout << "object coutn" << count <<endl;
	}
Point::showCount();
类的友元：C++提供的一种破坏数据封装和数据隐藏的机制。通过将一个模块声明为另一个模块的友元，一个模块能够引用到另一个模块中本是隐藏的信息。可以声明为友元函数和友元类。为了确保数据的完整性，及数据封装与隐藏的原则，建议慎用友元。
友元函数：友元函数是在声明由关键字friend修饰说明的非成员函数，在它的函数体中能够通过对象访问private和protected成员。
作用：增加灵活性，使程序员可以在封装和快速性方面做合理选择。
访问对象中的成员必须通过对象名
友元类：若一个类为另一个类的友元，则此类的所有成员都能访问对方的私有成员。
声明语法：将友元类名在另一个类中使用friend修饰说明。 
类的友元是单向的：声明B类是A类的友元！= A类是B类的友元。
共享数据的保护:常类型：
常对象：必须进行初始化，不能被更新。
常成员：用const进行修饰的类成员：常数据成员和常函数成员，只能在初始化列表中，不能再函数体中。
常引用：被引用的对象不能被更新。const类型说明符 &引用名；
常数组：数组元素不能被更新，类型说明符 const 数组名【大小】
常指针：指向常量的指针。
常成员函数：类型说明符 函数名（形式参数）const//可以重载函数的一部分。
常函数：常对象调用，普通对象也可以调用，作用:不改变对象的状态。
深层复制和浅层复制，由于复制的时候指针，指向的是同一个数组空间。
（c++11标准中提供）移动构造：

2016.10.5
//复制构造函数,其形参为本类的对象引用。作用是用一个已存在的对象去初始化一个新对象。
	class 类名{
		类名 (形参);//构造函数
		类名（const 类名 & 对象名）；//复制构造函数
	}
	类名::类(const 类名 &对象名)//复制构造函数的实现{函数体};
复制构造函数函数调用：
1.定义对象，以本类另一个对象作为初始值，发生复制构造。
2.如果函数的形参是类的对象，调用函数时，将使用实参对象初始化形参对象，发生复制构造。
3.如果函数的返回值是类的对象，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主调函数，此时发生复制构造。这种情况也可以通过移动构造避免不必要的复制。
不希望使用复制构造，复制构造声明为private
析构函数:对象啊消亡，自动调用（完成对象被删除的清理工作），没有声明析构函数生成默认的，函数体为空。没有参数，没有返回值。
类的组合：
类组合的构造函数设计，基本类成员初始化，对象成员。
组合：一个对象作为另一个类的形参，
前向引用声明，(两个类相互包含)
Class B;前向引用说明
class A{
}
UML简介：
UML三个基本部分：事物，关系，图，
类图： 
类的完整表示
clock
-hour:int
-minute:int
-second:int
+showTime():void
+setTime(newH:int = 0,newM:int = 0,news:int = 0):void
类的简介表示
作用关系 ==关联
类A 重数A --- 重数B 类重数B
图中 重数A决定了类B的每个对象与类A的多少个对象发生作用，同样 重数B 决定了类A的每个对象与类B的多少个对象发生作用。
包含关系 == 聚合 
类A 重数A 空心四边形---- 重数B 类重数B
共享聚集：部分可以参加多个整体（一个老师参加多个课题组）
类A 重数A 实心四边形---- 重数B 类重数B
组合聚集（组合）：整体拥有各个部分，整体与部分共享，如果整体不存在了，部分也就不存在了（窗体的组成成份）
struct 结构体名称{
private：
porceted:
}	
联合体 union Mark{
	char grade;
	bool pass;
	int percent;
}//按最大分配，只取一个值

2016.10.4
//逗号运算符,先进行左边运算，在进行右边运算，最后取右边的值。
	int a;
	a = 3*5,a*4;
	//逻辑运算符,&&两侧表达式都为真，结果为真，有一侧为假，结果为假。“短路特性”||两侧都为假，结果为假，有一侧为真则为真。
	sizeof (a);
	//& 按位与运算(&)（同时为一，结果为一），按位或运算(|)（对应位有一出一），按位异或运算(^)（若对应位相同，结果为0，若对应位不同，结果为1）。
	//按位取反（ ~） 位运算移位运算（<< ,>>）（左移运算，左移后，低位补0，高位舍弃，右移运算，低位舍弃，高位：无符号：补0，有符号，补符号）
	//运算符的优先级
内联（inline）函数
编译时调用处用函数体进行替换
节省了参数传递，控制转移开销。
注意：不能有循环和switch语句，内联函数必须出现在函数第一次调用之前，对内联函数不能进行异常接口声明。
C++函数重载（处理名称相同，功能不同的函数）
C++允许功能相近的函数在相同的作用域内以相同函数名声明，从而形成重载。方便使用，便于记忆。
int add(int, int);
float add(float, float);
注意事项：重载函数的形参必须相同：个数不同或类型不同。
编译器将根据实参的形参的类型和个数的最佳匹配来选择调用哪一个函数。
不要将不同功能的函数声明为重载函数，以免出现用结果的误解，
函数递归的调用（可以实现求取几个数的最大值）
判断float是否相同利用 abs(a - b) <= le-10

C++类的使用：
类的成员函数：可以在类中声明函数原型，也可以在类外给出函数体实现，并在函数名前使用类名加以限定；也可以直接在类中 给出函数体，形成内联成员函数；允许声明重载函数和带默认参数值得函数。
构造函数：（在对象被创建的时候使用特定的值构造对象，将对象初始化为一个特定的初始化状态）
构造与类名相同，在创建对象的时候，自动调用。
不声明构造函数，使用默认构造函数，否则使用自定义构造函数，
clock() = default;//自定义构造使用系统默认。
Clock::Clock(): hour(0),minute(0),second(0)//默认构造函数
{
}
Clock::Clock(int newH, int newM,int newS) : hour(newH),minute(newM),second(newS){ //初始化列表
}
默认情况下同时写上系统默认的构造函数，如上所示：
委托构造函数：可实现上述的内容两个构造函数，Clock():Clock(0,0,0){}；

2016.10.2（软件 = 程序 + 文档）
计算机系统简介：外部存储器，内部存储器（内存条）输入设备，CPU，输出设备。
指令系统：计算机能识别的机器语言（0和1组成），机器能识别的语言的集合
程序设计方法：一个系统由对象构成，对象之间通过消息传递进行沟通。
C++程序开发过程：算法设计，源程序编辑，编译，汇编，链接，运行调试。
C++泛型程序设计方法
信息的存储和表示：字符的表示，ASCII表。

同一类对象的共同属性和行为，称为类。
多态：同样的消息作用在不同的对象上，有可能引起不同的行为 。

2016.9.20
在复习OCBlock中测试blcok在控制器中的回调中发现，如果执行block（），在Appdelegete中的内容不会被调用。（可能是已经进入时间循环，而delegete并不在时间循环内部）
